---
title: Dll调用内存bug解决
date: 2024-03-26
category:
  - History
tag:
  - C++
---
# Dll调用内存bug解决

今天在C++调用opencv进行目标识别的时候，将cv中某类型的数据置入目标数组vector中，结果在MFC按钮点击事件结束后就会引发崩溃，如下所示：

![image-20240326010931269](https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/image-20240326010931269.png)

因为调用了opencv的dll的命令，dll就会拥有独立于应用程序的堆栈，程序自身无法访问该堆栈，所以Vector析构的时候就会报错。

原因分析如下：

exe运行库的链接方式为MD，而dll的链接方式为MT。

/MT和/MTd表示采用多线程CRT库的静态lib版本。该选项会在编译时将运行时库以静态lib的形式完全嵌入。该选项生成的可执行文件运行时不需要运行时库dll的参加，会获得轻微的性能提升，但最终生成的二进制代码因链入庞大的运行时库实现而变得非常臃肿。当某项目以静态链接库的形式嵌入到多个项目，则可能造成运行时库的内存管理有多份，最终将导致致命的“Invalid Address specified to RtlValidateHeap”问题。另外托管C++和CLI中不再支持/MT和/MTd选项。
/MD和/MDd表示采用多线程CRT库的动态dll版本，会使应用程序使用运行时库特定版本的多线程DLL。链接时将按照传统VC链接dll的方式将运行时库MSVCRxx.DLL的导入库MSVCRT.lib链接，在运行时要求安装了相应版本的VC运行时库可再发行组件包（当然把这些运行时库dll放在应用程序目录下也是可以的）。 因/MD和/MDd方式不会将运行时库链接到可执行文件内部，可有效减少可执行文件尺寸。当多项目以MD方式运作时，其内部会采用同一个堆，内存管理将被简化，跨模块内存管理问题也能得到缓解。
/MD和/MDd将是潮流所趋，/MT和/MTd在非必要时最好也不要采用了。
某个变量在exe里被初始化为空，但在dll里被改变大小，重新分配内存空间。在exe获取结果后释放局部变量时，其内部的容器初始的内存已无效，故出现错误。

> 其根源是在opencv库中分配了内存，但在销毁时却是在外面，所以导致失败。

故提供以下四种解决方案：

1.将所有项目运行库都以MD链接，因为opencv的官方dll不是我们自己写的，所以可以尝试下面的方法

2.将变量设置为全局变量，这样就不会调用析构函数了。

3.给opencv分配内存的vector设置足够大的内存，避免被dll重新分配内存，保证变量都是exe自身的内存，这样析构之后就不会报错了。

4.修改opencv源码，给vector析构的时候设置clear内存操作，让内存销毁在opencv中。

