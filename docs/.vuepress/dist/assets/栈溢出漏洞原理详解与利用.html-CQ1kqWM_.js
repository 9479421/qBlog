import{_ as p,o as t,c as e,e as o}from"./app-CC-6zdNz.js";const a={},s=o('<h1 id="栈溢出漏洞原理详解与利用" tabindex="-1"><a class="header-anchor" href="#栈溢出漏洞原理详解与利用"><span>栈溢出漏洞原理详解与利用</span></a></h1><p><strong>转载</strong></p><blockquote><p><strong>0x01 前言</strong></p></blockquote><p>和我一样，有一些计算机专业的同学可能一直都在不停地码代码，却很少关注程序是怎么执行的，也不会考虑到自己写的代码是否会存在栈溢出漏洞，借此机会我们一起走进栈溢出。</p><blockquote><p><strong>0x02 程序是怎么运行的</strong></p></blockquote><p>在了解栈溢出之前我们先了解一下程序执行过程</p><p>程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到call指令的下一条指令继续执行，函数调用过程通常使用堆栈实现</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/eaf81a4c510fd9f9f69912d71b5fa92c2934a47e.png@f_auto" alt="img"></p><p>编译成32位可执行文件，放在ollydbg中就行调试，来详细看一下执行过程</p><p>因为程序的执行可以看做一个一个函数的执行(main函数也一样)，因此我们挑选其中一个即可，在test1()函数设置断点</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/9345d688d43f8794354500ba976973f21ad53a60.jpeg@f_auto" alt="img"></p><p>F7单步调试第一步mov dword ptr ss:[esp],0x1，进行传参，简洁明了。</p><p><strong>第二步call mian.00401559</strong>，进入test()，这里我们关注一下esp和栈顶值，将该指令的下一条指令的地址进行压栈，既然有压栈那么就会有出栈，这就与函数中的retn指令形成呼应。</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/b3119313b07eca801e552705d551eadba044837c.jpeg@f_auto" alt="img"></p><p><strong>第三步push ebp</strong>，就是把ebp的值进行压栈，<strong>那么这个ebp是什么呢？有什么用呢？</strong></p><p>EBP叫做扩展基址指针寄存器(extended base pointer) ，里面放一个指针，该指针指向系统栈最上面一个栈帧的底部，用于C运行库访问栈中的局部变量和参数。那么这一步的意义就是：保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/1b4c510fd9f9d72adbd0f69490585532359bbb78.jpeg@f_auto" alt="img"></p><p><strong>第四步</strong>，mov ebp，esp，将esp的值放在ebp中，我们再来了解一下什么是esp？</p><p>ESP（Extended Stack Pointer）为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针，指向栈的栈顶（下一个压入栈的活动记录的顶部），也就是它不停在变，刚才提到的ebp指向栈底，在函数内部执行过程中是不变。</p><p>那么我们再看一下<strong>这一步的作用</strong>：</p><p>从第三步可以知道esp存储的值是旧栈帧中的帧基指针，而esp值栈顶指针，随时都在变，因此为了函数结束后能恢复，把esp值（外层函数栈底地址）保存在本函数栈底ebp中。简而言之，将内部函数ebp的值作为地址，它存放外函数的ebp的值。这一步在末尾也存在逆向指令leave。</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/3c6d55fbb2fb4316d2adf93f65d63b2508f7d3ba.jpeg@f_auto" alt="img"></p><p>**第五步是sub esp,0x28，**开辟该函数的局部变量空间</p><p>紧接着第六步mov dword ptr ss:[ebp-0xC],0x6，给变量a一个大小是0xC的空间，并且赋值。</p><p>然后就是传参字符1的ascii码，调用printf函数，把返回值放到eax。</p><p>我们重点来看leave指令，可以发现ebp的值恢复了，esp的值也变了，相当于mov esp,ebp;pop ebp</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/d1160924ab18972ba7fc9ef5a3bf068f9f510a47.jpeg@f_auto" alt="img"></p><p>最后执行retn指令，至此一个函数执行完毕，esp和eip的值都被改变，相当于pop eip，然后程序继续执行。EIP是指令寄存器，存放当前指令的下一条指令的地址。CPU该执行哪条指令就是通过EIP来指示的</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/5366d0160924ab1818a15b0a71889bcb7a890bd4.jpeg@f_auto" alt="img"></p><blockquote><p><strong>0x03 栈溢出</strong></p></blockquote><p>分析完这一过程，相信大家对函数是怎么执行的应该明朗了，那么我们言归正传，继续聊一下栈溢出。首先我们先看一下什么是栈？</p><p><strong>栈可以看作是一个漏斗，栈底地址大，栈顶地址小</strong>，然后在一个存储单元中，按照由小到大进行存储，它的目的是赋予程序一个方便的途径来访问特定函数的局部数据，并从函数调用者那边传递信息。</p><p><strong>栈溢出属于缓冲区溢出，指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。</strong></p><p>另外，我们也不难发现，发生栈溢出的基本前提是：程序必须向栈上写入数据、写入的数据大小没有被良好地控制。引用一个例子来了解一下栈溢出</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/4034970a304e251f2330960f9af4b4117d3e53fe.png@f_auto" alt="img"></p><p>很显然符合以上两个条件，gets()成为突破口我们在主函数处下断点，运行和调试</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/314e251f95cad1c817a78e303a4c1a0fc93d5105.jpeg@f_auto" alt="img"></p><p>lea eax，dword ptr ss:[ebp-0x14] 这时开辟一个空间给变量，也即是s，如图所示</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/2f738bd4b31c870153afe1ce190de3290708ff72.jpeg@f_auto" alt="img"></p><p>我们想执行sucess()函数，要怎么办呢？</p><p>执行完vulnerable()函数后，会还原ebp，改变esp的值(leave)，然后retn，也就是pop eip，然后CPU根据eip指针指向的指令继续运行。</p><p>**我们能抓到的点就是控制eip，****怎么控制？**通过控制栈顶的值，那么栈顶的值是什么？栈顶的值是进入该函数时储存的下一条指令的地址。这里提一点，进入函数，要保存两个值：下一条命令的地址、EBP旧栈帧的帧基指针，只有这样才能完全恢复。</p><p><strong>此时我们可以构造payload</strong>，来控制我们要控制的地方，栈中存储EBP值的存储单元的上一个存储单元，也就是图中的存储address的存储单元</p><p>我们先试验一下输入0x14 *&#39;A&#39;+BBBB+0000，发生的变化</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/9e3df8dcd100baa193bad8b17862c414c9fc2e9a.jpeg@f_auto" alt="img"></p><p>很好，按照我们的预想进行(python -c &#39;print &quot;A&quot;* 0x18+p32(0x00401520)&#39;) 就可以达到栈溢出的效果</p><p><img src="https://wqby-1304194722.cos.ap-nanjing.myqcloud.com/img/3801213fb80e7becf4461220115cc43e99506bcf.jpeg@f_auto" alt="img"></p>',47),n=[s];function c(g,m){return t(),e("div",null,n)}const r=p(a,[["render",c],["__file","栈溢出漏洞原理详解与利用.html.vue"]]),b=JSON.parse('{"path":"/view/note/%E5%8F%8D%E6%B1%87%E7%BC%96/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%88%A9%E7%94%A8.html","title":"栈溢出漏洞原理详解与利用","lang":"en-US","frontmatter":{},"headers":[],"git":{"updatedTime":1709311174000,"contributors":[{"name":"wqby","email":"9479421@qq.com","commits":1}]},"filePathRelative":"view/note/反汇编/栈溢出漏洞原理详解与利用.md","excerpt":"\\n<p><strong>转载</strong></p>\\n<blockquote>\\n<p><strong>0x01 前言</strong></p>\\n</blockquote>\\n<p>和我一样，有一些计算机专业的同学可能一直都在不停地码代码，却很少关注程序是怎么执行的，也不会考虑到自己写的代码是否会存在栈溢出漏洞，借此机会我们一起走进栈溢出。</p>\\n<blockquote>\\n<p><strong>0x02 程序是怎么运行的</strong></p>\\n</blockquote>\\n<p>在了解栈溢出之前我们先了解一下程序执行过程</p>\\n<p>程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到call指令的下一条指令继续执行，函数调用过程通常使用堆栈实现</p>"}');export{r as comp,b as data};
